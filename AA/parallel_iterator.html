<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="" lang=""><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Cours 4 : itérateurs parallèles</title>
  <style>
    html {
      line-height: 1.7;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 40em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin-top: 1.7em;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.7em;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1.7em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1.7em 0 1.7em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      font-style: italic;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      background-color: #f0f0f0;
      font-size: 85%;
      margin: 0;
      padding: .2em .4em;
    }
    pre {
      line-height: 1.5em;
      padding: 1em;
      background-color: #f0f0f0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin-top: 1.7em;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
    }
    th, td {
      border-bottom: 1px solid lightgray;
      padding: 1em 3em 1em 0;
    }
    header {
      margin-bottom: 6em;
      text-align: center;
    }
    nav a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Cours 4 : itérateurs parallèles</h1>
</header>
<p>Voici quelques notes rapides sur les points essentiels du cours.</p>
<p>L’objectif du cours est de présenter la notion d’itérateurs parallèles et plus particulièrement l’opération de réduction.</p>
<h2 id="itérateurs-parallèles">Itérateurs parallèles</h2>
<h3 id="vers-une-réduction-générique">Vers une réduction générique</h3>
<p>On part de l’algorithme de somme vu au cours précédent :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> somme(entree<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u64</span>]) <span class="op">-&gt;</span> <span class="dt">u64</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> entree<span class="op">.</span>len() <span class="op">&lt;=</span> <span class="dv">5_000</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        entree<span class="op">.</span>iter()<span class="op">.</span>sum()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> mid <span class="op">=</span> entree<span class="op">.</span>len() <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (gauche<span class="op">,</span> droite) <span class="op">=</span> entree<span class="op">.</span>split_at(mid)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (s_gauche<span class="op">,</span> s_droite) <span class="op">=</span> join(<span class="op">||</span> somme(gauche)<span class="op">,</span> <span class="op">||</span> somme(droite))<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        s_gauche <span class="op">+</span> s_droite</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>En remarquant que cet algorithme reste inchangé en passant de sommes à
 produits on peut écrire un algorithme plus abstrait capable de réaliser
 de nombreuses opérations.</p>
<p>Pour ce faire il va nous falloir par contre utiliser des types 
génériques en paramètres de notre fonction. On obtient ainsi le code 
suivant :</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reduce<span class="op">&lt;</span>T<span class="op">,</span> ID<span class="op">,</span> OP<span class="op">&gt;</span>(entree<span class="op">:</span> <span class="op">&amp;</span>[T]<span class="op">,</span> identity<span class="op">:</span> ID<span class="op">,</span> op<span class="op">:</span> OP) <span class="op">-&gt;</span> T</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    T<span class="op">:</span> <span class="bu">Copy</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    ID<span class="op">:</span> <span class="bu">Fn</span>() <span class="op">-&gt;</span> T <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    OP<span class="op">:</span> <span class="bu">Fn</span>(T<span class="op">,</span> T) <span class="op">-&gt;</span> T <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    reduce_rec(entree<span class="op">,</span> <span class="op">&amp;</span>identity<span class="op">,</span> <span class="op">&amp;</span>op)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reduce_rec<span class="op">&lt;</span>T<span class="op">,</span> ID<span class="op">,</span> OP<span class="op">&gt;</span>(entree<span class="op">:</span> <span class="op">&amp;</span>[T]<span class="op">,</span> identity<span class="op">:</span> <span class="op">&amp;</span>ID<span class="op">,</span> op<span class="op">:</span> <span class="op">&amp;</span>OP) <span class="op">-&gt;</span> T</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    T<span class="op">:</span> <span class="bu">Copy</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    ID<span class="op">:</span> <span class="bu">Fn</span>() <span class="op">-&gt;</span> T <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    OP<span class="op">:</span> <span class="bu">Fn</span>(T<span class="op">,</span> T) <span class="op">-&gt;</span> T <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> entree<span class="op">.</span>len() <span class="op">&lt;=</span> <span class="dv">5000</span> <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        entree<span class="op">.</span>iter()<span class="op">.</span>copied()<span class="op">.</span>fold(identity()<span class="op">,</span> op)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> mid <span class="op">=</span> entree<span class="op">.</span>len() <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (gauche<span class="op">,</span> droite) <span class="op">=</span> entree<span class="op">.</span>split_at(mid)<span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (s_gauche<span class="op">,</span> s_droite) <span class="op">=</span> join(</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">||</span> reduce_rec(gauche<span class="op">,</span> identity<span class="op">,</span> op)<span class="op">,</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">||</span> reduce_rec(droite<span class="op">,</span> identity<span class="op">,</span> op)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        op(s_gauche<span class="op">,</span> s_droite)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notons au passage l’utilisation de contraintes sur les types et notamment les traits <code>Fn</code> qui caractérisent les fonctions, <code>Send</code> qui autorise une variable d’un type à changer de thread et <code>Sync</code> qui autorise un passage par référence entre threads.</p>
<p>Notre algorithme peut ensuite être utilisé facilement pour de nombreuses opérations :</p>
<ul>
<li>la somme :</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    reduce(entree<span class="op">,</span> <span class="op">||</span> <span class="dv">0</span><span class="op">,</span> <span class="op">|</span>a<span class="op">,</span> b<span class="op">|</span> a <span class="op">+</span> b)</span></code></pre></div>
<ul>
<li>le produit :</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    reduce(entree<span class="op">,</span> <span class="op">||</span> <span class="dv">1</span><span class="op">,</span> <span class="op">|</span>a<span class="op">,</span> b<span class="op">|</span> a <span class="op">*</span> b)</span></code></pre></div>
<p>On peut en fait pousser la généralisation encore plus loin : en 
abstrayant le type d’entrée. En y réfléchissant bien on se rend compte 
que les propriétés nécessaires pour l’entrée sont :</p>
<ul>
<li>de produire un itérateur séquentiel sur des <code>T</code></li>
<li>d’être découpables en 2</li>
</ul>
<p>Ce type générique correspond à la notion d’<strong>itérateur parallèle</strong>. Comme il s’agit encore d’une abstraction ça il ne pourra pas s’agir d’un type concret mais d’un <em>trait</em> : <code>ParallelIterator</code>.</p>
<p>Pour utiliser ce trait il suffit de l’importer dans le scope avec</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">rayon::prelude::</span><span class="op">*;</span></span></code></pre></div>
<p>On disposera alors de tout un tas de nouvelles méthodes sur les types
 de base du langage permettant de créer des itérateurs parallèles.</p>
<p>Pour obtenir une range parallèle par exemple on écrira :</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>)<span class="op">.</span>into_par_iter()</span></code></pre></div>
<p>Pour un itérateur sur des éléments d’une tranche, par référence, on écrira :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>tranche<span class="op">.</span>par_iter()</span></code></pre></div>
<p>Les itérateurs parallèles tout comme les itérateurs séquentiels sont 
paresseux et ne réalisent aucune opération tant que personne ne les 
consomme.</p>
<p>La liste des méthodes utilisables sur ces itérateurs est disponible :</p>
<ul>
<li>pour les itérateurs parallèles simples <a href="https://docs.rs/rayon/1.3.0/rayon/iter/trait.ParallelIterator.html">ici</a></li>
<li>pour les itérateurs indicés <a href="https://docs.rs/rayon/1.3.0/rayon/iter/trait.IndexedParallelIterator.html">ici</a></li>
</ul>
<p>Les itérateurs indicés correspondent à ceux dont le ième élément est 
accessible facilement et disposent de méthodes supplémentaires, 
notamment <code>zip</code>.</p>
<p>Sur ces pages on peut par exemple retrouver notre réduction :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reduce<span class="op">&lt;</span>OP<span class="op">,</span> ID<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> identity<span class="op">:</span> ID<span class="op">,</span> op<span class="op">:</span> OP) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Item <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    OP<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">Self</span><span class="pp">::</span>Item<span class="op">,</span> <span class="dt">Self</span><span class="pp">::</span>Item) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Item <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="bu">Send</span><span class="op">,</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    ID<span class="op">:</span> <span class="bu">Fn</span>() <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Item <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="bu">Send</span><span class="op">,</span></span></code></pre></div>
<p>Le type <code>T</code> est simplement remplacé par <code>Self::Item</code>, le type associé des éléments sur lesquels on itère.</p>
<p>Pour réaliser la somme en parallèle des éléments d’un vecteur on utilisera ainsi simplement :</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">rayon::prelude::</span><span class="op">*;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_eq!</span>(v<span class="op">.</span>par_iter()<span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;</span>()<span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span></span></code></pre></div>
<h3 id="contrôle-de-la-création-des-tâches">Contrôle de la création des tâches</h3>
<p>En exécutant ce code avec deux threads et 500000 entiers on obtient le log suivant :</p>
<figure>
<img src="rayon_parallel_files/rayon.svg" alt="trace d’une somme parallèle avec rayon"><figcaption aria-hidden="true">trace d’une somme parallèle avec rayon</figcaption>
</figure>
<p>On peut remarquer que le comportement de l’algorithme de réduction de
 rayon ne correspond pas tout à fait au comportement que l’on observe 
avec notre algorithme de somme écrit manuellement. L’arbre est ici plus 
petit avec plus de tâches vertes créées que de tâches rouges.</p>
<p>C’est parce qu’il reste un problème avec notre algorithme générique :
 la calibration du seuil à partir duquel on doit retomber sur 
l’algorithme séquentiel. En effet, dans notre exemple de somme, j’ai 
pris un seuil arbitraire de 5000 éléments. En réalité trouver la bonne 
valeur du seuil n’est pas facile et peut nécessiter une petite phase 
d’expérimentations. Ces expériences dépendent malheureusement de 
l’algorithme ciblé et de la machine ciblée. Ceci pose un problème pour 
une écriture <strong>générique</strong> de notre opération de réduction. Pour cette raison, <em>rayon</em> utilise une heuristique pour décider de la création de nouvelles tâches.</p>
<p>L’idée c’est de découper (toujour récursivement) suffisament de 
tâches pour servir tous les threads puis de lier les découpes 
supplémentaires aux requêtes de vol. Si aucune requête n’a lieu (par 
exemple car tous les threads sont déjà occupés), il y aura donc <span class="math inline"><em>O</em>(<em>p</em>)</span> tâches créées.</p>
<p>On peut retrouver ce comportement dans notre code manuel. Pour 
réaliser cela il nous faudra être capable de détecter si une tâche est 
volée ou exécutée localement. Ceci est réalisable à l’aide d’un <code>join_context</code> qui fonctionne comme <code>join</code> mais nous fournit en plus cette information. On obtient alors le code suivant :</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reduce_rec<span class="op">&lt;</span>T<span class="op">,</span> ID<span class="op">,</span> OP<span class="op">&gt;</span>(entree<span class="op">:</span> <span class="op">&amp;</span>[T]<span class="op">,</span> identity<span class="op">:</span> <span class="op">&amp;</span>ID<span class="op">,</span> op<span class="op">:</span> <span class="op">&amp;</span>OP<span class="op">,</span> compte<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> T</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    T<span class="op">:</span> <span class="bu">Copy</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    ID<span class="op">:</span> <span class="bu">Fn</span>() <span class="op">-&gt;</span> T <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    OP<span class="op">:</span> <span class="bu">Fn</span>(T<span class="op">,</span> T) <span class="op">-&gt;</span> T <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> compte <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> entree<span class="op">.</span>len() <span class="op">&lt;=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        entree<span class="op">.</span>iter()<span class="op">.</span>copied()<span class="op">.</span>fold(identity()<span class="op">,</span> op)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> mid <span class="op">=</span> entree<span class="op">.</span>len() <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (gauche<span class="op">,</span> droite) <span class="op">=</span> entree<span class="op">.</span>split_at(mid)<span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (s_gauche<span class="op">,</span> s_droite) <span class="op">=</span> join_context(</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span>_<span class="op">|</span> reduce_rec(gauche<span class="op">,</span> identity<span class="op">,</span> op<span class="op">,</span> compte <span class="op">/</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span>c<span class="op">|</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>                reduce_rec(</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>                    droite<span class="op">,</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>                    identity<span class="op">,</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>                    op<span class="op">,</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">if</span> c<span class="op">.</span>migrated() <span class="op">{</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>                        <span class="dv">2</span> <span class="op">*</span> <span class="pp">rayon::</span>current_num_threads()</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>                        compte <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>                    <span class="op">},</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        op(s_gauche<span class="op">,</span> s_droite)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>En cas de vol, on ré-initialise le compteur de création de tâches 
pour recommencer à diviser. On obtient alors un comportement similaire à
 celui de <em>rayon</em>. Il n’est pas nécessaire de vérifier si la 
tâche de gauche est volée car celle-ci est toujours traitée localement 
(et immédiatement).</p>
<p>Cette optimisation permet de fortement réduire la taille de l’arbre. On passe ainsi de <span class="math inline">2<em>n</em></span> noeuds à <span class="math inline"><em>O</em>(<em>p</em>)</span>
 noeuds si tout se passe bien. Notons tout de même que si les threads ne
 sont pas synchronisés ou que le nombre de threads n’est pas une 
puissance de 2, l’arbre peut tout de même atteindre une profondeur de <span class="math inline"><em>l</em><em>o</em><em>g</em>(<em>n</em>)</span> comme sur le log réalisé avec trois threads, ci-dessous.</p>
<figure>
<img src="rayon_parallel_files/rayon3.svg" alt="trace d’une somme parallèle avec rayon (3 threads)"><figcaption aria-hidden="true">trace d’une somme parallèle avec rayon (3 threads)</figcaption>
</figure>
<p>Comme on ne coupe qu’en deux, il faut couper en 4 pour avoir plus de 
tâches que de threads. Chaque thread prend une tâche mais il reste alors
 une dernière tâche pour trois. On recommence alors une nouvelle étape 
de découpe, ce qui pousse une branche de l’arbre jusqu’à atteindre sa 
profondeur maximale. En raffraichissant la page web vous pouvez relancer
 l’animation pour bien voir ce qui se passe.</p>
<h2 id="écriture-dalgorithmes-parallèles">Écriture d’algorithmes parallèles</h2>
<p>Bon, on dispose maintenant de notre outil de base. Le truc qui est <strong>énorme</strong>
 c’est que si vous avez l’habitude d’utiliser les itérateurs en python 
vous écrivez en réalité déjà du code parallèle, sans le savoir. Pour 
beaucoup d’algorithmes il suffit en effet de remplacer <code>.iter()</code> par <code>.par_iter()</code>
 et voilà ! Un algorithme parallèle sans deadlocks, sécurisé par le 
compilateur, évitant tous les pièges de base de la programmation 
parallèle.</p>
<p>On peut maintenant écrire des algorithmes monstrueux en quelques lignes de code seulement.</p>
<p>Tout n’est pas toujours si simple par contre. Certains algorithmes 
sont écrits de manière intrinsèquement séquentielle même avec des 
itérateurs et nécessitent plus de travail.</p>
<p>C’est en particulier le cas dès que <code>fold</code> ou <code>scan</code> apparaissent dans le code car ces deux opérations nécessitent de faire transiter un état d’une itération sur l’autre.</p>
<p>On va essayer de regarder un exemple de ce style et j’ai repris 
l’exemple du TD sur le bin packing. Le code séquentiel est le suivant :</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> tailles<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">=</span> repeat_with(random)<span class="op">.</span>take(<span class="dv">10</span>)<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on calcule les bins.</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// il s'agit d'un vecteur tel que chaque case represente une bin.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// elle contient</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// - la place restante</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// - un vecteur contenant tout le contenu de la bin.</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bins<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>(<span class="dt">f64</span><span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>)<span class="op">&gt;</span> <span class="op">=</span> tailles<span class="op">.</span>iter()<span class="op">.</span>cloned()<span class="op">.</span>fold(<span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">,</span> <span class="op">|</span><span class="kw">mut</span> bins<span class="op">,</span> t<span class="op">|</span> <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> choix <span class="op">=</span> bins</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>iter_mut()</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>filter(<span class="op">|</span>(place_libre<span class="op">,</span> _)<span class="op">|</span> <span class="op">*</span>place_libre <span class="op">&gt;=</span> t)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>next()<span class="op">;</span> <span class="co">// on prend la premiere bin avec assez de place</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>((place_libre<span class="op">,</span> contenu)) <span class="op">=</span> choix <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>place_libre <span class="op">-=</span> t<span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            contenu<span class="op">.</span>push(t)<span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// si choix est None on rajoute une nouvelle bin.</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            bins<span class="op">.</span>push((<span class="dv">1.0</span> <span class="op">-</span> t<span class="op">,</span> <span class="pp">vec!</span>[t]))<span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        bins</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span></code></pre></div>
<p>Dans cet exemple, on crée une solution à partir d’un vecteur vide et 
chaque tour de boucle le remplit un peu plus. Le vecteur est passé d’un 
tour à l’autre par le <code>fold</code> qui nous indique clairement que quelque chose de séquentiel a lieu ici.</p>
<p>On pourrait en fait réécrire le code d’une manière différente pour faire disparaître le <code>fold</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> bins<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>(<span class="dt">f64</span><span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>)<span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    tailles<span class="op">.</span>iter()<span class="op">.</span>cloned()<span class="op">.</span>for_each(<span class="op">|</span>t<span class="op">|</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> choix <span class="op">=</span> bins</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>iter_mut()</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>filter(<span class="op">|</span>(place_libre<span class="op">,</span> _)<span class="op">|</span> <span class="op">*</span>place_libre <span class="op">&gt;=</span> t)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>next()<span class="op">;</span> <span class="co">// on prend la premiere bin avec assez de place</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>((place_libre<span class="op">,</span> contenu)) <span class="op">=</span> choix <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>place_libre <span class="op">-=</span> t<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            contenu<span class="op">.</span>push(t)<span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// si choix est None on rajoute une nouvelle bin.</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            bins<span class="op">.</span>push((<span class="dv">1.0</span> <span class="op">-</span> t<span class="op">,</span> <span class="pp">vec!</span>[t]))<span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span></code></pre></div>
<p>On fait simplement une boucle sur toutes les tailles et on modifie 
simplement le vecteur à chaque tour au travers d’une référence mutable.</p>
<p>Il semblerait facile ici de remplacer <code>tailles.iter()</code> par <code>tailles.par_iter()</code> mais le code ne compile alors pas et donne le message d’erreur suivant :</p>
<pre><code>error[E0596]: cannot borrow `bins` as mutable, as it is a captured variable in a `Fn` closure
  --&gt; src/main.rs:16:21
   |
16 |         let choix = bins
   |                     ^^^^
   |
help: consider changing this to accept closures that implement `FnMut`
  --&gt; src/main.rs:15:42
   |
15 |       tailles.par_iter().cloned().for_each(|t| {
   |  __________________________________________^
16 | |         let choix = bins
17 | |             .iter_mut()
18 | |             .filter(|(place_libre, _)| *place_libre &gt;= t)
...  |
26 | |         }
27 | |     });
   | |_____^</code></pre>
<p>Le message n’est pas facile à comprendre la première fois qu’on le 
voit. En fait il existe trois traits gouvernant les fonctions : <code>Fn</code>, <code>FnOnce</code>, <code>FnMut</code>. <code>FnOnce</code> désigne les fonctions que l’on ne peut appeller qu’une seule fois, par exemple les closures qui réalisent un <em>move</em>. <code>FnMut</code> les fonctions qui empruntent quelque chose de manière mutable et modifient donc quelque chose par effet de bord, et <code>Fn</code> les fonctions qui ne font que des empruns en lecture.</p>
<p>La closure que l’on passe en argument à <code>for_each</code> modifie <code>bins</code> et nécessite donc un accès mutable. Cette closure implémente donc le trait <code>FnMut</code> mais pas le trait <code>Fn</code>. Or le prototype de <code>for_each</code> est le suivant :</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> for_each<span class="op">&lt;</span>OP<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> op<span class="op">:</span> OP) <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    OP<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">Self</span><span class="pp">::</span>Item) <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="bu">Send</span><span class="op">,</span></span></code></pre></div>
<p>Le compilateur nous sauve donc (les push concurrents sur le vecteur seraient potentiellement incorrects).</p>
<p>On ne s’en sortira donc pas avec le <code>for_each</code>.</p>
<p>Heureusement il existe dans rayon une opération de <code>fold</code> parallèle. Celle-ci fonctionne en créant un état par tâche (un vecteur donc ici). Le <code>fold</code>
 parallèle ne fournit donc pas un vecteur en sortie mais tout un 
ensemble de vecteurs, sous forme d’un itérateur parallèle. On passe donc
 d’un itérateur parallèle sur des tailles à un itérateur sur des 
solutions partielles. Il reste ensuite à fusionner entre elles ces 
solutions à l’aide d’une réduction.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> fusion(<span class="kw">mut</span> bins1<span class="op">:</span> Bins<span class="op">,</span> <span class="kw">mut</span> bins2<span class="op">:</span> Bins) <span class="op">-&gt;</span> Bins <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// subgraph permet de tagger les taches dans rayon_logs</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    subgraph(<span class="st">"fusion"</span><span class="op">,</span> bins1<span class="op">.</span>len() <span class="op">+</span> bins2<span class="op">.</span>len()<span class="op">,</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// on va fusionner les deux bins a moitie vides</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// si elles existent</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> max1 <span class="op">=</span> bins1</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>iter()</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>map(<span class="op">|&amp;</span>(s<span class="op">,</span> _)<span class="op">|</span> s)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>enumerate()</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>max_by(<span class="op">|</span>(_<span class="op">,</span> sa)<span class="op">,</span> (_<span class="op">,</span> sb)<span class="op">|</span> sa<span class="op">.</span>partial_cmp(<span class="op">&amp;</span>sb)<span class="op">.</span>unwrap()) <span class="co">// f64 n'implemente pas Ord</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>map(<span class="op">|</span>(i<span class="op">,</span> _)<span class="op">|</span> i)<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> max2 <span class="op">=</span> bins2</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>iter()</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>map(<span class="op">|&amp;</span>(s<span class="op">,</span> _)<span class="op">|</span> s)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>enumerate()</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>max_by(<span class="op">|</span>(_<span class="op">,</span> sa)<span class="op">,</span> (_<span class="op">,</span> sb)<span class="op">|</span> sa<span class="op">.</span>partial_cmp(<span class="op">&amp;</span>sb)<span class="op">.</span>unwrap())</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>map(<span class="op">|</span>(i<span class="op">,</span> _)<span class="op">|</span> i)<span class="op">;</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(i1) <span class="op">=</span> max1 <span class="op">{</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(i2) <span class="op">=</span> max2 <span class="op">{</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> bins1[i1]<span class="op">.</span><span class="dv">0</span> <span class="op">+</span> bins2[i2]<span class="op">.</span><span class="dv">0</span> <span class="op">&gt;=</span> <span class="dv">1.0</span> <span class="op">{</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> bin2 <span class="op">=</span> bins2<span class="op">.</span>swap_remove(i2)<span class="op">;</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>                    bins1[i1]<span class="op">.</span><span class="dv">1</span><span class="op">.</span>extend(bin2<span class="op">.</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>                    bins1[i1]<span class="op">.</span><span class="dv">0</span> <span class="op">+=</span> bin2<span class="op">.</span><span class="dv">0</span> <span class="op">-</span> <span class="dv">1.0</span><span class="op">;</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        bins1<span class="op">.</span>extend(bins2)<span class="op">;</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        bins1</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> bin_packing() <span class="op">{</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> tailles<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="dv">0</span><span class="op">..</span><span class="dv">32</span>)<span class="op">.</span>into_par_iter()<span class="op">.</span>map(<span class="op">|</span>_<span class="op">|</span> random())<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bins<span class="op">:</span> Bins <span class="op">=</span> tailles</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>par_iter()</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>cloned()</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>fold(</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">||</span> <span class="op">-&gt;</span> Bins <span class="op">{</span> <span class="dt">Vec</span><span class="pp">::</span>new() <span class="op">},</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span><span class="kw">mut</span> bins<span class="op">,</span> t<span class="op">|</span> <span class="op">{</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> choix <span class="op">=</span> bins</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>iter_mut()</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>filter(<span class="op">|</span>(place_libre<span class="op">,</span> _)<span class="op">|</span> <span class="op">*</span>place_libre <span class="op">&gt;=</span> t)</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>next()<span class="op">;</span> <span class="co">// on prend la premiere bin avec assez de place</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>((place_libre<span class="op">,</span> contenu)) <span class="op">=</span> choix <span class="op">{</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>                    <span class="op">*</span>place_libre <span class="op">-=</span> t<span class="op">;</span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>                    contenu<span class="op">.</span>push(t)<span class="op">;</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// si choix est None on rajoute une nouvelle bin.</span></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>                    bins<span class="op">.</span>push((<span class="dv">1.0</span> <span class="op">-</span> t<span class="op">,</span> <span class="pp">vec!</span>[t]))<span class="op">;</span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>                bins</span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>reduce(<span class="dt">Vec</span><span class="pp">::</span>new<span class="op">,</span> <span class="op">|</span>b1<span class="op">,</span> b2<span class="op">|</span> fusion(b1<span class="op">,</span> b2))<span class="op">;</span></span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>L’algorithme de fusion de deux solutions partielles concatène les 
bins des deux solutions et fusionne les deux bins demi-vide si elles 
existent.</p>
<p>On obtient ainsi le log suivant :</p>
<figure>
<img src="rayon_parallel_files/fold.svg" alt="trace du bin packing, 2 threads, 1000 tailles"><figcaption aria-hidden="true">trace du bin packing, 2 threads, 1000 tailles</figcaption>
</figure>
<p>On peut voir ici le <code>collect</code> parallèle en haut du graphe 
puis les folds (longues lignes horizontales) et enfin toutes les 
opérations de réduction. Toutes les réductions représentent un surcoût 
par rapport à l’algorithme séquentiel et il est intéressant de calculer 
le travail de l’algo parallèle. On pourrait également paralléliser la 
fusion pour réduire la profondeur.</p>


</body></html>